import matplotlib
import matplotlib.pyplot as plt
#from gridData import Grid
import numpy as np
from scipy.optimize import fsolve
import MDAnalysis as mda
from MDAnalysis.analysis.density import DensityAnalysis
from MDAnalysis.analysis.rdf import InterRDF 
from MDAnalysis.coordinates.memory import MemoryReader
from MDAnalysis.analysis.base import AnalysisFromFunction
from MDAnalysis.tests.datafiles import XTC, TRR
from MDAnalysis import transformations as trans
from scipy.optimize import curve_fit
import matplotlib.colors as colors
import pickle
import gc

matplotlib.use('Agg')

droplet = True # True if is the system a droplet, if False it is considered a bubble
save_data = True # Save the results of the data analysis in a pkl file
analyze_densities = True # True if is required an analysis of the density profile, False if the pkl files are already provided. In this case the program will only plot these data
save_figure = True # Save the figures generated by the analysis
data_analysis = True # Save the results of the data analysis in .txt files
there_is_solute = True # False if the system is made of pure water, True if there is some solute
sphere = False # True if the system has spherical symmetry
cylinder = False # True if it has cylindical symmetry. If both this variable and 'sphere' are False, the system will be considered as having a plane symmetry along the 'z' direction
analysis_cog = False # Use the center of geometry of the molecules to define its position
analysis_com = True # Use the center of mass of the molecules to define its position
analysis_oxy = False # Use the position of the oxygen atom to perform the analysis instead of the position of the molecules
analysis_carb = False # Use the position of the last carbon atom to perform the analysis instead of the position of the molecules (if the and all the previous 'analysis_' variables are False it uses all the atoms of each molecules)
analysis_angle = True # Calculate the angle between the center of symmetry of the system and the molecular axis
dummy_atom= False # Use also the method of the 'dummy atom' to calculate 
calc_virial = False # Calculate the components of the virial pressure (it does not work for solutions)

if calc_virial:
    dummy_atom = False


n_blocks = 4 # number of blocks in which we want to split the simulations data to perform a separate statistical analysis


if droplet:
    n_sigma_smooth = 3
else:
    n_sigma_smooth = 1

sigma = 1.0
sigma_d_b = 3.0
sigma_d_v = 3.0

tol_grad = 0.05
if not droplet:
    tol_grad = 0.001

if calc_virial:
    tol_grad_d = 0.0000001
else:
    tol_grad_d = 0.00001

if droplet and not (sphere or cylinder):
    tol_grad_d = 0.00002



#realizations_traj=['_1','_2','_3','_4']
#realizations_traj=['_1','_2','_3']
realizations_traj=['_1']
#realizations_traj=['_1','_2','_3','_4','_5','_6','_7','_8','_9','_10','_11','_12','_13']
#realizations_traj=['_1','_2','_3','_4','_5','_7','_8','_9','_10','_11','_12','_13']
#realizations_traj=['_1']
fix = '_fix'
#comment = '_13realiz'
#comment = realizations_traj[-1]
comment = realizations_traj[-1]+'_bl2'

if calc_virial:
    comment = comment + '_virial'

if droplet:
    if (sphere or cylinder):
        nbins1=3000
    else:
        nbins1=500
else: 
#    comment = comment+'_noshift'
    #comment = comment+'_new'
    comment = comment+fix
    #comment = comment+'_fittrans1'
    nbins1=1000

part= '.part0003'

conv_A_to_nm = 0.1
conv_Am3_to_nmm3 = 1000.0

kB =0.0083144621# in kJ/(mol K) ## #1.380649*10**(-26)in kJ/K
#kB =1.380649*10**(-26) #in kJ/K
mass_conv = (1.66053*10**(-27))
#mass_conv = 1.0
conv_J_kJsumol = 1.0/(1.66053*10.0**(-21))
#conv_kJsumolAng_JsuM =0.0083144621# in kJ/(mol K) ## #1.380649*10**(-26)in kJ/K
#conv_kJsumolAng_JsuM = 1.66053907 * 10**(-21)
conv_kJsumolAng_N = (1.66054*10.0**(-11))
conv_kJsumolnm_N = (1.66054*10.0**(-12))
conv_kJsumolAng_mN = conv_kJsumolAng_N*10.0**(3)
conv_kJsumolnm_mN = conv_kJsumolnm_N*10.0**(3)
conv_N_pN = 10.0**(12)
conv_A_nm = 0.1
conv_A_m = 10.0**(-10)
conv_nm_m = 10.0**(-9)
temperature = 300.0

depth_cylinder = 50.0 # (in Angstrom)

slab_area  = 2500.0 # (in Angstrom)

if  there_is_solute:

   #title='Methanol'
   #densatom=1.0/6.0 #methanol
   #densatom_h=1.0/6.0 #methanol
   #abbrev='_m'
   #code_mol = '3PY5'
   #ox_name = 'O5'
   #ca_name = 'C1'

   #title='Ethanol'
   #densatom=1.0/9.0 #ethanol
   #densatom_h=1.0/9.0 #ethanol
   #abbrev='_et'
   #code_mol = '_U1K'
   #ox_name = '...'
   #ca_name = 'C1'
 
   #title='Propanol'
   #densatom=1.0/12.0 #propanol
   #densatom_h=1.0/12.0 #propanol
   #abbrev='_pr'
   #code_mol = '6ZJN'
   #ox_name = 'OAB'
   #ca_name = 'CAA'

   #title='Pentanol'
   #densatom=1.0/18.0 #pentanol
   #densatom_h=1.0/18.0 #pentanol
   #abbrev='_pe'
   #code_mol = 'KBSB'
   #ox_name = 'O1'
   #ca_name = 'C1'

   title='octanol'
   densatom=1.0/27.0 #octanol
   densatom_h=1.0/27.0 #octanol
   abbrev='_oc'
   code_mol = '4WP3'
   ox_name = 'O9'
   ca_name = 'C1'

   
   #title='dodecanol'
   #densatom=1.0/39.0 #dodecanol
   #densatom_h=1.0/39.0 #dodecanol
   #abbrev='_do'
   #code_mol = '5BUD'
   #ox_name = 'O2S'
   #ca_name = 'C12'

   

   #mol_sol_vec=[10,20,30,40]#meth 
   #mol_sol_vec=[35,70]#meth tube 12
   #mol_sol_vec=[70]#meth tube 12
   #mol_sol_vec=[60]#meth sphere 8
   #mol_sol_vec=[5,10,20,40]#meth tube 3p5
   #mol_sol_vec=[6,15,30,40]#meth tube 5
   #mol_sol_vec=[8,16,24,32]#etha tube 7, sphere 6p5 5p5
   #mol_sol_vec=[8,16,32,48,64]#etha tube 7, sphere 6p5 5p5
   #mol_sol_vec=[6,12,18,24]#etha tube 3p5 4 5 , spehere 4p5 4
   #mol_sol_vec=[8,12,16]#prop sphere
   #mol_sol_vec=[4,8,12,16]#prop sphere
   #mol_sol_vec=[24]#prop sphere 8
   #mol_sol_vec=[14,28]#prop tube 12
   #mol_sol_vec=[28]#prop tube 12
   #mol_sol_vec=[46]
   #mol_sol_vec=[46,90,140]#spherical bubble 5p4
   #mol_sol_vec=[28,54,80]#spherical bubble 4p5
   #mol_sol_vec=[15,30,45]#spherical bubble 3p3
   #mol_sol_vec=[20,30]#
   #mol_sol_vec=[14,26,38]#cylindrical bubble 7
   #mol_sol_vec=[10,20,30]#cylindrical bubble 4p5
   #mol_sol_vec=[7,13,20]#cylindrical bubble 3p5
   #mol_sol_vec=[2,4,6,8]#pent, prop 3p5
   #mol_sol_vec=[7,14]#pent tube 12
   #mol_sol_vec=[12]#pent sphere 12
   #mol_sol_vec=[2,4,6,8,16,24,32]#pent, prop 3p5
   #mol_sol_vec=[2,4,6,8,16,32]# prop flat
   #mol_sol_vec=[2,4,6,8,12,16]# tha flat
   #mol_sol_vec=[8,16,32,48,64,80,96,112,128,160,208,256,512]# meth flat
   #mol_sol_vec=[2,4,6,8]# pent flat
   #mol_sol_vec=[2,4,6,8,12,16,24,32,48,64,80,96,120]# etha flat
   #mol_sol_vec=[48,64,80,96,120]#pent, prop 3p5
   mol_sol_vec=[2]# oct
   #mol_sol_vec=[1]# dod

   leng_box='13'
else:
   title='Water'
   code_mol = 'SOL'
   mol_sol_vec=[0]#water
   leng_box='10' 

#size='l3p5'
#size='l4'
size='l12'
#size='r3p3' 




fnt_sz = 20 #font size for labels

if analysis_cog:
    refer = '_cog'
    densatom=1.0
    densatom_h=1.0
    densatom_w=1.0 #water
    comment = comment+'_cog'
elif analysis_com:
    refer = '_com'
    densatom=1.0
    densatom_h=1.0
    densatom_w=1.0 #water
    comment = comment+'_com'
elif analysis_oxy:
    refer = '_oxy'
    densatom=1.0
    densatom_h=1.0
    densatom_w=1.0 #water
    comment = comment+'_oxy'
elif analysis_carb:
    refer = '_carb'
    densatom=1.0
    densatom_h=1.0
    comment = comment+'_carb'

else:
    refer = ''
    densatom_w=1.0/3.0 # factor to calculate water density

virial_3d = []
virial_3d2 = []
delta_virial_3d = []

for mol_sol in mol_sol_vec:
    #if mol_sol == 30:
    #   part= '_rest.part0001'
    #   #part= '_cont.part0001'
    #   #part= '.part0002'
    #else:
    #   part= '.part0003'
    if analyze_densities:

        time_vec = []
        com_coord_vec = []
       
        density_wat_rad = []
        density_wat_rad_rdf = []
        dens_smooth_d  = []
        dens_smooth = [] 
        vap_th = [] 
        bulk_th = [] 
        vap_th_d = [] 
        bulk_th_d = [] 

        mean_angle = []  
        mean_angle_stddev = [] 
        sq_mean_angle = [] 
        sq_mean_angle_stddev = [] 

        if there_is_solute:
            density_sol_rad = []
            density_sol_rad_rdf = []
            dens_smooth_sol_d = [] 
            dens_smooth_sol = [] 

        n_frames = 0

        frame_numbers = []

        distance_list_sol = [] #create lists to hold the values of the distances
        distance_list_wat = [] #create lists to hold the values of the distances
        virial_list = [] #create lists to hold the values of the virials
        virial_list2 = [] #create lists to hold the values of the virials
        cos_theta_list = [] #create lists to hold the values of the angles
    
        for realization in realizations_traj:
 
            time_vec.append([])
            com_coord_vec.append([])

            if droplet:
               altr=''
            else:
               altr='_new7'

            if title=='Pentanol' or ( not sphere and not cylinder) : 
                if ( not sphere and not cylinder) : 
                        u = mda.Universe('folder_n'+str(mol_sol)+realization+'/topol_n'+str(mol_sol)+'_l'+leng_box+realization+altr+'.tpr', 'folder_n'+str(mol_sol)+realization+'/evol_num'+str(mol_sol)+'_len'+leng_box+realization+'.part0002.xtc')# slab
                else:
                    if calc_virial:
                        u = mda.Universe('folder_n'+str(mol_sol)+'_'+size+realization+'/topol_n'+str(mol_sol)+'_l'+leng_box+realization+altr+'.tpr', 'folder_n'+str(mol_sol)+'_'+size+realization+'/evol_num'+str(mol_sol)+'_len'+leng_box+realization+'.part0002.trr')# pent
                    else:
                        u = mda.Universe('folder_n'+str(mol_sol)+'_'+size+realization+'/topol_n'+str(mol_sol)+'_l'+leng_box+realization+altr+'.tpr', 'folder_n'+str(mol_sol)+'_'+size+realization+'/evol_num'+str(mol_sol)+'_len'+leng_box+realization+fix+'.part0002.xtc')# pent
            else:
                if calc_virial:
                    if sphere:
                        u = mda.Universe('folder_n'+str(mol_sol)+'_'+size+realization+'/topol_n'+str(mol_sol)+'_l'+leng_box+realization+altr+'.tpr',['folder_n'+str(mol_sol)+'_'+size+realization+'/evol_num'+str(mol_sol)+'_len'+leng_box+realization+'.part0001.trr','folder_n'+str(mol_sol)+'_'+size+realization+'/evol_num'+str(mol_sol)+'_len'+leng_box+realization+'.part0002.trr','folder_n'+str(mol_sol)+'_'+size+realization+'/evol_num'+str(mol_sol)+'_len'+leng_box+realization+fix+part+'.trr'])
                    else:
                        u = mda.Universe('folder_n'+str(mol_sol)+'_'+size+realization+'/topol_n'+str(mol_sol)+'_l'+leng_box+realization+altr+'.tpr',['folder_n'+str(mol_sol)+'_'+size+realization+'/evol_num'+str(mol_sol)+'_len'+leng_box+realization+fix+part+'.trr'])
                else:
                    u = mda.Universe('folder_n'+str(mol_sol)+'_'+size+realization+'/topol_n'+str(mol_sol)+'_l'+leng_box+realization+altr+'.tpr', 'folder_n'+str(mol_sol)+'_'+size+realization+'/evol_num'+str(mol_sol)+'_len'+leng_box+realization+fix+part+'.xtc')# meth prop
            if not calc_virial:
                if droplet:
                    u.transfer_to_memory(step=2)
                else:
                    u.transfer_to_memory(step=1)
           
            n_frames += len(u.trajectory[int(len(u.trajectory[:])/10):])
          
            if leng_box=='18':
                leng_an = 90
            elif leng_box=='16':
                leng_an = 80
            elif leng_box=='15':
                leng_an = 75
            elif leng_box=='14':
                leng_an = 70
            elif leng_box=='13':
                leng_an = 65
            elif leng_box=='12':
                leng_an = 60
            elif leng_box=='11':
                leng_an = 55
            elif leng_box=='10':
                leng_an = 50
            elif leng_box=='9':
                leng_an = 45
            elif leng_box=='8':
                leng_an = 40
            else:
                print('Wrong length')
                exit()

            print(u.trajectory)
            #print(atoms.trajectory)
            #print(atoms.residues.positions.center_of_mass())
                                           
            #print(u.residues)
            print(u.atoms[-5:])
            #print(u.select_atoms('resname SOL and type OW').positions)
            print('----------')
            #print(u.select_atoms('resid 100-100').positions)
            #print(len(u.trajectory[25000:]))
            print(int(len(u.trajectory[:])/10))
            #for ts in u.trajectory[:20]:
            #    time = u.trajectory.time
            #    time2 = ts.time
            #    rgyr = u.atoms.radius_of_gyration()
            #    print("Frame: {:3d}, Time: {:4.0f} ps, Rgyr: {:.4f} A".format(ts.frame, time, rgyr))
            #    print("Frame: {:3d}, Time2: {:4.0f} ps, Rgyr: {:.4f} A".format(ts.frame, time2, rgyr))
                    

            atoms =  u.select_atoms('resname '+code_mol+'  or resname SOL')
            # altra prova
            #if not droplet:
            if False:
                #transform = mda.transformations.fit_translation(u, u, weights="mass")
                transform = trans.fit_translation(u, u, weights="mass")

                ag = u.residues[1].atoms
                ts = MDAnalysis.transformations.center(ag,center='mass')(ts)
                ts = MDAnalysis.transformations.translate( u.dimensions[0:3]/2.0)(ts)

                #transform = trans.fit_translation(frame,u , weights="mass")
                #transform = trans.fit_translation(atoms,u , weights="mass")
                u.trajectory.add_transformations(transform)
            # qui finisce la prova         


            if analysis_oxy:
               atoms_wat =  u.select_atoms('resname SOL and type OW')
            else:
               atoms_wat =  u.select_atoms('resname SOL')

            if there_is_solute and analysis_oxy:
                atoms_sol =  u.select_atoms('resname '+code_mol+' and type O*')
                #atoms_sol =  u.select_atoms('resname '+code_mol+' and type '+ox_name)
                print(atoms_sol)
            elif there_is_solute and analysis_carb:
                atoms_sol =  u.select_atoms('resname '+code_mol+' and name C1')
            elif there_is_solute:
                atoms_sol =  u.select_atoms('resname '+code_mol)

            if analysis_angle:
                #atoms_sol_c1 =  u.select_atoms('resname '+code_mol+' and name CAA')
                atoms_sol_c1 =  u.select_atoms('resname '+code_mol+' and name '+ca_name)
                atoms_sol_oxy =  u.select_atoms('resname '+code_mol+' and type O*')
     
            
            ######  Calculation of using the density
            ## questa e la prova
            #atom_com = mda.Universe.empty(1,n_residues=1,trajectory=True)
            ##atom_com.add_TopologyAttr('resid', list(range(1, 2)))
            #atom_com.add_TopologyAttr('resname', ['COM']*1)
            #atom_com.dimensions = u.dimensions
            #atom_com.trajectory = u.trajectory
            #coordinates = AnalysisFromFunction(lambda ag: ag.center_of_mass(),
            #                                   u.atoms).run().results['timeseries'] 

            #if not droplet:
            if False:
                 atoms.positions = atoms.positions.copy() + u.dimensions[0:3]/2.0
                 atoms_wat.positions = atoms_wat.positions.copy() + u.dimensions[0:3]/2.0
                 atoms_sol.positions = atoms_sol.positions.copy() + u.dimensions[0:3]/2.0
                 if analysis_angle:
                     atoms_sol_oxy.positions = atoms_sol_oxy.positions.copy() + u.dimensions[0:3]/2.0
                     atoms_sol_c1.positions = atoms_sol_c1.positions.copy() + u.dimensions[0:3]/2.0
 
                 atoms.pack_into_box()
                 atoms_wat.pack_into_box()
                 atoms_sol.pack_into_box()
                 if analysis_angle:
                     atoms_sol_oxy.pack_into_box()
                     atoms_sol_c1.pack_into_box()

     
            frame_numbers.append([])

            if calc_virial:
                init_s= 12
                delta_s=10
            else:
                init_s= int(len(u.trajectory[:])/10)  #perche????
                delta_s=1

            print(len(u.trajectory[:]))
            print('--')
            print(atoms)
            print('--')

            #for frame in u.trajectory[init_s::delta_s]:
            for frame in u.trajectory[init_s::]: # questa e quella che va messa
                #print('f:',frame.has_forces)
                #print('v:',frame.has_velocities)
                #print('p:',frame.has_positions)
                #print(frame.time)
                #if frame.has_forces:
                #   print('for:',frame.time)
                #if frame.has_positions:
                #   print('pos:',frame.time)

                ## questa e la prova
                #for frame in atom_com.trajectory[init_s::]:
                #    #arr[:, frame.frame] = atoms.center_of_mass()#compound='residues')
                #    #atom_com.atoms.positions[0,:] = atoms.center_of_mass()#compound='residues')
                #    #atom_com.atoms.positions[0,:] = coordinates[frame.frame,:]
                #
                #    atom_com.atoms.translate(coordinates[frame.frame,:]-atom_com.atoms.positions[0,:])
                ## qui finisce la prova

                   #print('and:',frame.time)
                if not droplet:
                     atoms.positions = atoms.positions.copy() + u.dimensions[0:3]/2.0
                     #atoms_wat.positions = atoms_wat.positions.copy() + u.dimensions[0:3]/2.0
                     #atoms_sol.positions = atoms_sol.positions.copy() + u.dimensions[0:3]/2.0
                     #if analysis_angle:
                     #    atoms_sol_oxy.positions = atoms_sol_oxy.positions.copy() + u.dimensions[0:3]/2.0
                     #    atoms_sol_c1.positions = atoms_sol_c1.positions.copy() + u.dimensions[0:3]/2.0
 
                     atoms.pack_into_box()
                     #atoms_wat.pack_into_box()
                     #atoms_sol.pack_into_box()
                     #if analysis_angle:
                     #    atoms_sol_oxy.pack_into_box()
                     #    atoms_sol_c1.pack_into_box()

                     com_coord = - u.dimensions[0:3]/2.0 + atoms.center_of_mass() #cartesian coords of COM

                     jjj = 0
                     while ( np.linalg.norm(com_coord) > 0.01 and jjj < 100):
                         jjj += 1
 
                         #com_coord = atoms.center_of_mass() #cartesian coords of COM
                         
                         atoms.positions = atoms.positions.copy() - com_coord + u.dimensions[0:3]
                         #atoms_wat.positions = atoms_wat.positions.copy() - com_coord + u.dimensions[0:3]
                         #atoms_sol.positions = atoms_sol.positions.copy() - com_coord + u.dimensions[0:3]
                         #if analysis_angle:
                         #    atoms_sol_oxy.positions = atoms_sol_oxy.positions.copy() - com_coord + u.dimensions[0:3]
                         #    atoms_sol_c1.positions = atoms_sol_c1.positions.copy() - com_coord + u.dimensions[0:3]
                         
                         atoms.pack_into_box()
                         #atoms_wat.pack_into_box()
                         #atoms_sol.pack_into_box()
                         #if analysis_angle:
                         #    atoms_sol_oxy.pack_into_box()
                         #    atoms_sol_c1.pack_into_box()
                     
                         com_coord = - u.dimensions[0:3]/2.0 + atoms.center_of_mass() #cartesian coords of COM
                         #print('iter ',jjj,': ',atoms.center_of_mass(),np.linalg.norm(com_coord))
                     #if ( jjj ==100): 
                     #    print('jjj =100')

                     atoms.positions = atoms.positions.copy() + u.dimensions[0:3]/2.0
                     #atoms_wat.positions = atoms_wat.positions.copy() + u.dimensions[0:3]/2.0
                     #atoms_sol.positions = atoms_sol.positions.copy() + u.dimensions[0:3]/2.0
                     #if analysis_angle:
                     #    atoms_sol_oxy.positions = atoms_sol_oxy.positions.copy() + u.dimensions[0:3]/2.0
                     #    atoms_sol_c1.positions = atoms_sol_c1.positions.copy() + u.dimensions[0:3]/2.0
                     
                     #frame = mda.transformations.wrap(frame)
                     #transform = trans.wrap(atoms)
                     #u.trajectory.add_transformations(transform)
                     atoms.pack_into_box()
                     #atoms_wat.pack_into_box()
                     #atoms_sol.pack_into_box()
                     #if analysis_angle:
                     #    atoms_sol_oxy.pack_into_box()
                     #    atoms_sol_c1.pack_into_box()
                     
                     #print('final: ',jjj,' pos:',atoms.center_of_mass())
                     
                     #com_coord =  np.asarray([0.0,0.0,0.0]) 
                     #com_coord = u.dimensions[0:3]/2.0 - (atoms.center_of_mass()-u.dimensions[0:3]/2.0) #cartesian coords of COM
                     com_coord =   u.dimensions[0:3]/2.0

                if calc_virial: 

                   if False:
                       #atoms.positions = atoms.positions.copy() + u.dimensions[0:3]/2.0
                       #atoms_wat.positions = atoms_wat.positions.copy() + u.dimensions[0:3]/2.0
                       #atoms_sol.positions = atoms_sol.positions.copy() + u.dimensions[0:3]/2.0
                       #if analysis_angle:
                       #    atoms_sol_oxy.positions = atoms_sol_oxy.positions.copy() + u.dimensions[0:3]/2.0
                       #    atoms_sol_c1.positions = atoms_sol_c1.positions.copy() + u.dimensions[0:3]/2.0
 
                       #atoms.pack_into_box()
                       #atoms_wat.pack_into_box()
                       #atoms_sol.pack_into_box()
                       #if analysis_angle:
                       #    atoms_sol_oxy.pack_into_box()
                       #    atoms_sol_c1.pack_into_box()

                       #transform = mda.transformations.fit_translation(u, u, weights="mass")
                       #transform = trans.fit_translation(u, u, weights="mass")
                       
                       ##ag = u.residues[1].atoms
                       #print('cm1: ',atoms.center_of_mass())
                       frame = mda.transformations.center_in_box(atoms,center='mass',wrap=True)(frame)
                       #print('cm2: ',atoms.center_of_mass())
                       #frame = mda.transformations.center_in_box(atoms,center='mass',wrap=True)(frame)
                       #print('cm3: ',atoms.center_of_mass())
                       #frame = mda.transformations.center_in_box(atoms,center='mass',wrap=True)(frame)
                       #print('cm4: ',atoms.center_of_mass())
                       #frame = mda.transformations.center_in_box(atoms,center='mass',wrap=True)(frame)
                       #print('cm5: ',atoms.center_of_mass())
                       #frame = mda.transformations.center_in_box(atoms,center='mass',wrap=True)(frame)
                       #print('cm6: ',atoms.center_of_mass())

                       #frame = mda.transformations.translate( u.dimensions[0:3]/2.0)(frame)

                       #atoms.positions[1] = atoms.positions.copy()[1] + u.dimensions[1]/2.0
                       atoms.positions = atoms.positions.copy() + u.dimensions[0:3]/2.0
                       #atoms_wat.positions = atoms_wat.positions.copy() + u.dimensions[0:3]/2.0
                       #atoms_sol.positions = atoms_sol.positions.copy() + u.dimensions[0:3]/2.0
                       #if analysis_angle:
                       #    atoms_sol_oxy.positions = atoms_sol_oxy.positions.copy() + u.dimensions[0:3]/2.0
                       #    atoms_sol_c1.positions = atoms_sol_c1.positions.copy() + u.dimensions[0:3]/2.0

                       #frame = mda.transformations.wrap(frame)
                       #transform = trans.wrap(atoms)
                       #u.trajectory.add_transformations(transform)
                       #atoms_wat.pack_into_box()
                       #atoms_sol.pack_into_box()
                       #if analysis_angle:
                       #    atoms_sol_oxy.pack_into_box()
                       #    atoms_sol_c1.pack_into_box()


                       atoms.positions[1] = atoms.positions.copy()[1] - u.dimensions[1]/2.0
                       atoms.pack_into_box()


                   #transform = trans.fit_translation(frame,u , weights="mass")
                   #transform = trans.fit_translation(atoms,u , weights="mass")
                   #u.trajectory.add_transformations(transform)


                   #if False:
                   #     com_coord =  u.dimensions[0:3]/2.0
                   else:
                        com_coord = atoms.center_of_mass() #cartesian coords of COM
                        if (frame.has_forces and frame.has_positions):
                            if sphere:
                                atoms.positions = atoms.positions.copy() + u.dimensions[0:3]/2.0 - com_coord
                                com_coord = atoms.center_of_mass() #cartesian coords of COM
                                atoms.positions = atoms.positions.copy() + np.asarray([0.0,u.dimensions[1]/2.0,0.0 ])
                                #atoms.positions = atoms.positions.copy() + np.asarray([u.dimensions[0]/2.0,0.0,0.0 ])
                                atoms.pack_into_box()
                            else:
                                atoms.positions = atoms.positions.copy() + u.dimensions[0:3]/2.0 - com_coord
                            com_coord = atoms.center_of_mass() #cartesian coords of COM

                            #atoms_positions = np.asarray(atoms_wat.positions)
                            #atoms_positions = np.asarray(atoms.positions)
                            atoms_positions = np.asarray(frame.positions)
                            #atoms_forces = np.asarray(atoms_wat.forces)
                            #atoms_forces = np.asarray(atoms.forces)
                            atoms_forces = np.asarray(frame.forces)
                            atoms_masses = np.asarray(atoms.masses)
                            #cent_of_mass =  np.asarray(atoms_wat.center_of_mass(compound='molecules'))
                            #atoms_velocities = np.asarray(atoms.velocities)
                            atoms_velocities = np.asarray(frame.velocities)

                            #last_frame = ua[-1]
                            #print(last_frame.has_x,last_frame.has_v,last_frame.has_f)
                            #atoms_forces = ua.ts._forces
                            #atoms_positions = ua.ts.positions
                            print('pos:',atoms_positions.shape,atoms_forces.shape,(atoms_forces[:,0]).shape)
                            #virial1 = np.sum(-atoms_forces[:,0]* (atoms_positions[:,0]-com_coord[0])/2.0   )#
                            #virial1 = np.sum(-atoms_forces[:,0]* (atoms_positions[:,0])/2.0   )#
                            virial1 = np.sum(-atoms_forces[:,0]* (atoms_positions[:,0]-u.dimensions[0]/2.0)/2.0   )#
                            virial1 = np.dot(-atoms_forces[:,0], (atoms_positions[:,0]-u.dimensions[0]/2.0)/2.0   )#
                            #virial1 = np.sum(-atoms.forces[:,0]* (atoms.positions[:,0]-u.dimensions[0]/2.0)   )#
                            #virial2 = np.sum(-atoms_forces[:,1]* (atoms_positions[:,1]-com_coord[1])/2.0   )#
                            #virial2 = np.sum(-atoms_forces[:,1]* (atoms_positions[:,1])/2.0   )#
                            virial2 = np.sum(-atoms_forces[:,1]* (atoms_positions[:,1]-u.dimensions[1]/2.0)/2.0   )#
                            virial2 = np.dot(-atoms_forces[:,1], (atoms_positions[:,1]-u.dimensions[1]/2.0)/2.0   )#
                            #virial2 = np.sum(-atoms.forces[:,1]* (atoms.positions[:,1]-u.dimensions[1]/2.0)   )#
                            #virial3 = np.sum(-atoms_forces[:,2]* (atoms_positions[:,2]-com_coord[2])/2.0   )#
                            #virial3 = np.sum(-atoms_forces[:,2]* (atoms_positions[:,2])/2.0   )#
                            virial3 = np.sum(-atoms_forces[:,2]* (atoms_positions[:,2]-u.dimensions[2]/2.0)/2.0   )#
                            virial3 = np.dot(-atoms_forces[:,2], (atoms_positions[:,2]-u.dimensions[2]/2.0)/2.0   )#
                            #virial3 = np.sum(-atoms.forces[:,2]* (atoms.positions[:,2]-u.dimensions[2]/2.0)   )#

                            temp1 = np.sum((mass_conv*atoms_masses[:]*atoms_velocities[:,0]**2)/2.0)#
                            temp2 = np.sum((mass_conv*atoms_masses[:]*atoms_velocities[:,1]**2)/2.0)#
                            temp3 = np.sum((mass_conv*atoms_masses[:]*atoms_velocities[:,2]**2)/2.0)#
                            #print('pos:',np.mean(atoms_positions[:,0]),np.mean(atoms_positions[:,1]),np.mean(atoms_positions[:,2]))
                            #print('for:',np.mean(atoms_forces[:,0]),np.mean(atoms_forces[:,1]),np.mean(atoms_forces[:,2]))
                            #print('coo:',com_coord)
                            print('virial:',virial1,virial2,virial3)
                            print('kin:',temp1*10000.0*conv_J_kJsumol,temp2*10000.0*conv_J_kJsumol,temp3*10000.0*conv_J_kJsumol)
                            print('temp:',temp1*10000.0*conv_J_kJsumol*2.0/(kB*atoms_masses.shape[0]),temp2*10000.0*conv_J_kJsumol*2.0/(kB*atoms_masses.shape[0]),temp3*10000.0*conv_J_kJsumol*2.0/(kB*atoms_masses.shape[0]))
                            print('temp:',(temp1+temp2+temp3)*10000.0*conv_J_kJsumol*2.0/(2.0*kB*atoms_masses.shape[0]))

                            virial_list.append([virial1,virial2,virial3])
                            exit()
                           
                            #ag_updating1 = u.select_atoms("prop x < 75.")#, updating=True)
                            #ag_updating2 = u.select_atoms("prop x > 75.")#, updating=True)
                            #com_coorda = ag_updating1.center_of_mass() #cartesian coords of COM
                            #com_coordb = ag_updating2.center_of_mass() #cartesian coords of COM

                            #if com_coord_old is not None:
                            #    virial1a = np.sum(-atoms_forces[0,:] * (atoms_positions[0,:]-com_coord)/2.0,where=(atoms_positions[1,:]<com_coord) )#a * u.dimensions[0]
                            #    virial1b = np.sum(-atoms_forces[0,:] * (atoms_positions[0,:]-com_coord)/2.0,where=(atoms_positions[1,:]>com_coord) )#b * u.dimensions[0]
                            #    virial2a = np.sum(-atoms_forces[1,:] * (atoms_positions[1,:]-com_coord)/2.0,where=(atoms_positions[1,:]<com_coord) )#a * u.dimensions[1]
                            #    virial2b = np.sum(-atoms_forces[1,:] * (atoms_positions[1,:]-com_coord)/2.0,where=(atoms_positions[1,:]>com_coord) )#b * u.dimensions[1]
                            #    virial3a = np.sum(-atoms_forces[2,:] * (atoms_positions[2,:]-com_coord)/2.0,where=(atoms_positions[1,:]<com_coord) )#a * u.dimensions[2]
                            #    virial3b = np.sum(-atoms_forces[2,:] * (atoms_positions[2,:]-com_coord)/2.0,where=(atoms_positions[1,:]>com_coord) )#b * u.dimensions[2]
                            #    
                            #    virial1a = np.sum(-atoms_forces[0,:]* (com_coord-com_coord_old)/2.0   )#
                            #    virial2a = np.sum(-atoms_forces[1,:]* (com_coord-com_coord_old)/2.0   )#
                            #    virial3a = np.sum(-atoms_forces[2,:]* (com_coord-com_coord_old)/2.0   )#
                            #    #virial_list2.append([virial1a,virial2a,virial3a])
 
                            #    print('coo a b:',com_coorda,com_coordb)
                            #    print('vira',virial,virial1a,virial2a,virial3a)
                            #    print('virb',virial,virial1b,virial2b,virial3b)
                            #com_coord_old = com_coord
                            #virial1 = -virial1a-virial1b+virial1
                            #virial2 = -virial2a-virial2b+virial2
                            #virial3 = -virial3a-virial3b+virial3
 
                           
                            virial = np.linalg.norm(-atoms_forces * (atoms_positions- u.dimensions[0:3]/2.0)/2.0, axis=0)
                            #com_coord = atoms.center_of_mass() #cartesian coords of COM
                            #virial = np.linalg.norm(-atoms_forces * (atoms_positions-com_coord)/2.0, axis=0)
                            #virial = np.linalg.norm(-atoms_forces * (atoms_positions)/2.0, axis=0)
                            #virial = np.linalg.norm(-atoms_forces * (atoms_positions-np.asarray([75.0,0.0,75.0]))/2.0, axis=0)

                            virial_list2.append(virial)

                            if sphere:
                                atoms.positions = atoms.positions.copy() + np.asarray([0.0,u.dimensions[1]/2.0,0.0 ])
                                atoms.pack_into_box()
                                com_coord = atoms.center_of_mass() #cartesian coords of COM
                                atoms.positions = atoms.positions.copy() + u.dimensions[0:3]/2.0 - com_coord
                else:
                    #com_coord =   u.dimensions[0:3]/2.0
                    com_coord = atoms.center_of_mass() #cartesian coords of COM
                    #com_coord = atoms.center_of_geometry() #cartesian coords of COM

                    #com_coord1=atom_com.select_atoms('resname COM')
                    #com_coord=com_coord1.atoms.positions[0,:]
                    #com_coord=atom_com.atoms.positions[0,:]

                if there_is_solute:
                    if sphere:
                        if analysis_cog:
                            dist_sol = np.linalg.norm(atoms_sol.center_of_geometry(compound='molecules') - com_coord, axis=1)# sphere
                        elif analysis_com:
                            dist_sol = np.linalg.norm(atoms_sol.center_of_mass(compound='molecules') - com_coord, axis=1)# sphere
                        else:
                            dist_sol = np.linalg.norm(atoms_sol.positions - com_coord, axis=1)# sphere
                
                        if analysis_angle:
                            #dist_sol_oxy = np.linalg.norm(atoms_sol_oxy.positions - com_coord, axis=1)# sphere
                            dist_sol_oxy = np.linalg.norm(atoms_sol.center_of_mass(compound='molecules') - com_coord, axis=1)# sphere
                            dist_sol_c1 = np.linalg.norm(atoms_sol_c1.positions - atoms_sol_oxy.positions, axis=1)# sphere
                            #cos_angl = np.sum((atoms_sol_oxy.positions- com_coord)*(atoms_sol_c1.positions-atoms_sol_oxy.positions), axis=1)/(dist_sol_oxy*dist_sol_c1)
                            cos_angl = np.sum((atoms_sol.center_of_mass(compound='molecules')- com_coord)*(atoms_sol_c1.positions-atoms_sol_oxy.positions), axis=1)/(dist_sol_oxy*dist_sol_c1)
                
                    elif cylinder:
                        if analysis_cog:
                             dist_sol = np.linalg.norm(np.asarray(atoms_sol.center_of_geometry(compound='molecules'))[:,(0,2)] - np.asarray([com_coord[0],com_coord[2]]), axis=1)  # cylinder
                        elif analysis_com:
                             dist_sol = np.linalg.norm(np.asarray(atoms_sol.center_of_mass(compound='molecules'))[:,(0,2)] - np.asarray([com_coord[0],com_coord[2]]), axis=1)  # cylinder
                        else:
                             dist_sol = np.linalg.norm(np.asarray(atoms_sol.positions)[:,(0,2)] - np.asarray([com_coord[0],com_coord[2]]), axis=1)  # cylinder
                
                        if analysis_angle:
                            dist_sol_oxy = np.linalg.norm(atoms_sol.center_of_mass(compound='molecules')[:,(0,2)] - np.asarray([com_coord[0],com_coord[2]]), axis=1)# cylinder
                            #dist_sol_oxy = np.linalg.norm(np.asarray(atoms_sol_oxy.positions)[:,(0,2)] - np.asarray([com_coord[0],com_coord[2]]), axis=1)# cylinder
                            #dist_sol_c1 = np.linalg.norm(np.asarray(atoms_sol_c1.positions)[:,(0,2)] - np.asarray(atoms_sol_oxy.positions)[:,(0,2)], axis=1)
                            dist_sol_c1 = np.linalg.norm(atoms_sol_c1.positions - atoms_sol_oxy.positions, axis=1)# 
                            #cos_angl =  np.sum((np.asarray(atoms_sol_oxy.positions)[:,(0,2)]- np.asarray([com_coord[0],com_coord[2]]))*(np.asarray(atoms_sol_c1.positions)[:,(0,2)]-np.asarray(atoms_sol_oxy.positions)[:,(0,2)]), axis=1)/(dist_sol_oxy*dist_sol_c1)
                            cos_angl =  np.sum((atoms_sol.center_of_mass(compound='molecules')[:,(0,2)]- np.asarray([com_coord[0],com_coord[2]]))*(np.asarray(atoms_sol_c1.positions)[:,(0,2)]-np.asarray(atoms_sol_oxy.positions)[:,(0,2)]), axis=1)/(dist_sol_oxy*dist_sol_c1)
                    else:
                        if analysis_cog:
                             dist_sol = np.fabs(np.asarray(atoms_sol.center_of_geometry(compound='molecules'))[:,2] - com_coord[2])  # slab
                        elif analysis_com:
                             dist_sol = np.fabs(np.asarray(atoms_sol.center_of_mass(compound='molecules'))[:,2] - com_coord[2])  # slab
                             #dist_sol = np.linalg.norm(np.asarray(atoms_sol.center_of_mass(compound='molecules'))[:,2] - com_coord[2], axis=0)  # slab
                        else:
                             dist_sol = np.fabs(np.asarray(atoms_sol.positions)[:,2] - com_coord[2])  # slab
                
                        if analysis_angle:
                            #dist_sol_oxy = np.fabs(np.asarray(atoms_sol_oxy.positions)[:,2] - com_coord[2])# flat
                            dist_sol_oxy = np.fabs(atoms_sol.center_of_mass(compound='molecules')[:,2] - com_coord[2])# flat
                              #dist_sol_oxy = np.linalg.norm(np.asarray(atoms_sol_oxy.positions)[:,2] - com_coord[2], axis=0)# flat
                              #dist_sol_c1 = np.linalg.norm(np.asarray(atoms_sol_c1.positions)[:,2] - np.asarray(atoms_sol_oxy.positions)[:,2], axis=1)
                            dist_sol_c1 = np.linalg.norm(atoms_sol_c1.positions - atoms_sol_oxy.positions, axis=1)# 
                             ##cos_angl =  np.sum((np.asarray(atoms_sol_c1.positions)[:,(0,1)]-np.asarray(atoms_sol_oxy.positions)[:,(0,1)]), axis=1)*(np.asarray(atoms_sol_oxy.positions)[:,2] - com_coord[2])/(dist_sol_oxy*dist_sol_c1)
                            #cos_angl =  (np.asarray(atoms_sol_c1.positions)[:,2]-np.asarray(atoms_sol_oxy.positions)[:,2])*(np.asarray(atoms_sol_oxy.positions)[:,2] - com_coord[2])/(dist_sol_oxy*dist_sol_c1)
                            cos_angl =  (np.asarray(atoms_sol_c1.positions)[:,2]-np.asarray(atoms_sol_oxy.positions)[:,2])*(atoms_sol.center_of_mass(compound='molecules')[:,2] - com_coord[2])/(dist_sol_oxy*dist_sol_c1)
                 
                    distance_list_sol.append(dist_sol)
            
                if analysis_angle:
                    cos_theta_list.append(cos_angl)
            
            
              
                if sphere:
                    if analysis_cog:
                        dist_wat = np.linalg.norm(atoms_wat.center_of_geometry(compound='molecules') - com_coord, axis=1)# sphere
                    elif analysis_com:
                        dist_wat = np.linalg.norm(atoms_wat.center_of_mass(compound='molecules') - com_coord, axis=1)# sphere
                    else:
                        dist_wat = np.linalg.norm(atoms_wat.positions - com_coord, axis=1)# sphere
                elif cylinder:
                    if analysis_cog:
                        dist_wat = np.linalg.norm(np.asarray(atoms_wat.center_of_geometry(compound='molecules'))[:,(0,2)] - np.asarray([com_coord[0],com_coord[2]]), axis=1)  # cylinder
                    elif analysis_com:
                        dist_wat = np.linalg.norm(np.asarray(atoms_wat.center_of_mass(compound='molecules'))[:,(0,2)] - np.asarray([com_coord[0],com_coord[2]]), axis=1)  # cylinder
                    else:
                        dist_wat = np.linalg.norm(np.asarray(atoms_wat.positions)[:,(0,2)] - np.asarray([com_coord[0],com_coord[2]]), axis=1)  # cylinder
                else:
                    if analysis_cog:
                        dist_wat = np.fabs(np.asarray(atoms_wat.center_of_geometry(compound='molecules'))[:,2] - com_coord[2])  # slab
                    elif analysis_com:
                        dist_wat = np.fabs(np.asarray(atoms_wat.center_of_mass(compound='molecules'))[:,2] - com_coord[2])  # slab
                    else:
                        dist_wat = np.fabs(np.asarray(atoms_wat.positions)[:,2] - com_coord[2])  # slab
                
                distance_list_wat.append(dist_wat)
                counter = frame.frame 
                time_vec[-1].append(frame.time)
                com_coord_vec[-1].append(com_coord)
                frame_numbers[-1].append(counter)


        
        for jj in range(0,n_blocks):

            if calc_virial: 
                print(atoms_forces.shape)
                print(atoms_positions.shape)
                print(atoms_forces[0,:].shape)
                print(atoms_forces[:,0].shape)
                print(atoms_forces[10,0] )
                print('ll',np.asarray(virial_list)[int(n_frames*jj/n_blocks):int(n_frames*(jj+1)/n_blocks),:])
                #print('ll',np.asarray(virial_list)[int(n_frames*jj/n_blocks)+1:int(n_frames*(jj+1)/n_blocks),:])
                #print('ll',np.asarray(virial_list)[int(n_frames*jj/n_blocks):int(n_frames*(jj+1)/n_blocks)-2,:])
           
                virial_3d.append( np.mean(np.asarray(virial_list)[int(n_frames*jj/n_blocks):int(n_frames*(jj+1)/n_blocks),:],axis = 0) ) 
                virial_3d2.append( np.mean(np.asarray(virial_list2)[int(n_frames*jj/n_blocks):int(n_frames*(jj+1)/n_blocks),:],axis = 0) ) 
                #delta_virial_3d.append( np.mean(np.asarray(virial_list)[int(n_frames*jj/n_blocks)+1:int(n_frames*(jj+1)/n_blocks),:]-np.asarray(virial_list)[int(n_frames*jj/n_blocks):int(n_frames*(jj+1)/n_blocks)-2,:],axis = 0) ) 
    
                print(virial_3d,virial_3d2)
    
            #print('oo',jj,np.asarray(distance_list_wat)[int(n_frames*jj/n_blocks):int(n_frames*(jj+1)/n_blocks),:])
            #print('oo',jj,n_frames,n_blocks,np.asarray(distance_list_wat).shape)
            counts_wat, lengths_wat = np.histogram(np.asarray(distance_list_wat)[int(n_frames*jj/n_blocks):int(n_frames*(jj+1)/n_blocks),:],bins=nbins1,range=(0,leng_an))
            n_frames2 = float( int(n_frames*(jj+1)/n_blocks) - int(n_frames*jj/n_blocks) )
            counts_wat = counts_wat/n_frames2
    
            if sphere:
                shell_area_wat = 4.0 * np.pi * (lengths_wat[1:]**3 - lengths_wat[:-1]**3)/3.0 # sphere
            elif cylinder:
                shell_area_wat = np.pi * (lengths_wat[1:]**2 - lengths_wat[:-1]**2)*depth_cylinder # cylinder
            else:
                shell_area_wat =  (lengths_wat[1:] - lengths_wat[:-1])*slab_area # slab
    
            counts_wat = densatom_w*counts_wat/(shell_area_wat)  
    
            if there_is_solute:
    
                dist_array = np.asarray(distance_list_sol)[int(n_frames*jj/n_blocks):int(n_frames*(jj+1)/n_blocks),:]
    
                if analysis_angle:
                    angle_arr = np.asarray(cos_theta_list)[int(n_frames*jj/n_blocks):int(n_frames*(jj+1)/n_blocks),:]
    
                counts_sol, lengths_sol = np.histogram(dist_array,bins=nbins1,range=(0,leng_an))
    
                counts_sol = counts_sol/n_frames2 
    
                if sphere:
                    shell_area_sol = 4.0 * np.pi * (lengths_sol[1:]**3 - lengths_sol[:-1]**3)/3.0# sphere
                elif cylinder:
                    shell_area_sol = np.pi * (lengths_sol[1:]**2 - lengths_sol[:-1]**2)*depth_cylinder # cylinder
                else:
                    shell_area_sol =  (lengths_sol[1:] - lengths_sol[:-1])*slab_area # slab

                counts_sol = densatom*counts_sol/(shell_area_sol) 
    
    
            delta_conv_d = lengths_wat[1]-lengths_wat[0]
            len_conv_d = 2*int(n_sigma_smooth*sigma_d_b/delta_conv_d)+1
            gx_d = np.linspace(-delta_conv_d*len_conv_d, delta_conv_d*len_conv_d, len_conv_d ,endpoint=True)
            print('gx:',gx_d)
            gaussian_d = np.exp(-(gx_d/sigma_d_b)**2/2)
            gauss_norm_d= np.trapz(gaussian_d,dx=delta_conv_d)/delta_conv_d
            gauss_norm_d= float(np.mean(gaussian_d)*gx_d.shape[0])
            gaussian_d = gaussian_d/gauss_norm_d
            print('gaussian_d:',gaussian_d)
    
    
            dens_smooth_d.append(  np.convolve(gaussian_d, counts_wat ,mode='valid') )
            r_smooth_d = lengths_wat[int((len_conv_d-1)/2):-int((len_conv_d-1)/2)]
            r_smooth_d = (r_smooth_d[1:]+r_smooth_d[:-1])/2.0
            if there_is_solute:
                dens_smooth_sol_d.append(  np.convolve(gaussian_d, counts_sol ,mode='valid') )
                r_smooth_sol_d = lengths_sol[int((len_conv_d-1)/2):-int((len_conv_d-1)/2)]
                r_smooth_sol_d = (r_smooth_sol_d[1:]+r_smooth_sol_d[:-1])/2.0
     
            
            #init_gr =  np.argmin(np.abs(dens_smooth-10000))
               #grady = np.gradient(ndimage.filters.gaussian_filter(dens_cy_w[kk][kfe], [smooth_grad,smooth_grad], mode='constant'))
   
            j = 0
            print( np.abs(np.gradient(dens_smooth_d[-1],delta_conv_d)[0]) , tol_grad_d)
            print(dens_smooth_d[-1])
            while np.abs(np.gradient(dens_smooth_d[-1],delta_conv_d)[j]) < tol_grad_d:
                print( r_smooth_d[j],np.abs(np.gradient(dens_smooth_d[-1],delta_conv_d)[j]) , tol_grad_d)
                j+=1
    
            bulk_th_d.append( conv_A_to_nm*r_smooth_d[j] ) #np.argmin(np.abs(dens_smooth_d[j][-1] - counts_wat))]

            j = len(dens_smooth_d[-1])-1
            print( 'ff')
    
            delta_conv_d = lengths_wat[1]-lengths_wat[0]
            len_conv_d = 2*int(n_sigma_smooth*sigma_d_v/delta_conv_d)+1
            gx_d = np.linspace(-delta_conv_d*len_conv_d, delta_conv_d*len_conv_d, len_conv_d ,endpoint=True)
            print('gx:',gx_d)
            gaussian_d = np.exp(-(gx_d/sigma_d_v)**2/2)
            gauss_norm_d= np.trapz(gaussian_d,dx=delta_conv_d)/delta_conv_d
            gauss_norm_d= float(np.mean(gaussian_d)*gx_d.shape[0])
            gaussian_d = gaussian_d/gauss_norm_d
            print('gaussian_d:',gaussian_d)
    
    
            dens_smooth_d.append(  np.convolve(gaussian_d, counts_wat ,mode='valid') )
            r_smooth_d = lengths_wat[int((len_conv_d-1)/2):-int((len_conv_d-1)/2)]
            r_smooth_d = (r_smooth_d[1:]+r_smooth_d[:-1])/2.0
            if there_is_solute:
                dens_smooth_sol_d.append(  np.convolve(gaussian_d, counts_sol ,mode='valid') )
                r_smooth_sol_d = lengths_sol[int((len_conv_d-1)/2):-int((len_conv_d-1)/2)]
                r_smooth_sol_d = (r_smooth_sol_d[1:]+r_smooth_sol_d[:-1])/2.0
     
    
            print( np.abs(np.gradient(dens_smooth_d[-1],delta_conv_d)[j]) , tol_grad_d)
            while np.abs(np.gradient(dens_smooth_d[-1],delta_conv_d)[j]) < tol_grad_d:
                print( np.abs(np.gradient(dens_smooth_d[-1],delta_conv_d)[j]) , tol_grad_d)
                j-=1
    
            vap_th_d.append( conv_A_to_nm*r_smooth_d[j] ) #np.argmin(np.abs(dens_smooth_d[-1][j] - counts_wat))]
             
            print(len(dens_smooth_d[-1]),len(r_smooth_d),len_conv_d)
            print(len(dens_smooth_d[-1]*4.0*np.pi*r_smooth_d**2))
            number_wat = np.trapz(dens_smooth_d[-1]*4.0*np.pi*(r_smooth_d)**2,x=r_smooth_d[:])
            density_wat_rad.append( conv_Am3_to_nmm3*counts_wat )
            radius_wat = conv_A_to_nm*(lengths_wat[:-1]+lengths_wat[1:])/2
    
            if there_is_solute:
               radius_sol = conv_A_to_nm*(lengths_sol[:-1]+lengths_sol[1:])/2
               number_sol = np.trapz(dens_smooth_sol_d[-1]*4.0*np.pi*(r_smooth_sol_d)**2,x=r_smooth_sol_d[:])
               density_sol_rad.append( conv_Am3_to_nmm3*counts_sol )
    
               if analysis_angle:
                   #if not (np.any(np.isnan(cos_angl)):
                   size_vec = np.mean(np.ones_like(angle_arr) , where=(np.logical_and(np.logical_not(np.isnan(angle_arr)),np.logical_and( dist_array > bulk_th_d[-1]/conv_A_to_nm,dist_array < vap_th_d[-1]/conv_A_to_nm))))*angle_arr.size

                   mean_angle.append( np.mean(angle_arr, where=(np.logical_and(np.logical_not(np.isnan(angle_arr)),np.logical_and( dist_array > bulk_th_d[-1]/conv_A_to_nm,dist_array < vap_th_d[-1]/conv_A_to_nm)))) )
                   mean_angle_stddev.append( np.std(angle_arr, where=(np.logical_and(np.logical_not(np.isnan(angle_arr)),np.logical_and( dist_array > bulk_th_d[-1]/conv_A_to_nm,dist_array < vap_th_d[-1]/conv_A_to_nm))),ddof=1)/np.sqrt(size_vec) )
                                                                  
                   sq_mean_angle.append( np.mean(angle_arr**2 , where=(np.logical_and(np.logical_not(np.isnan(angle_arr)),np.logical_and( dist_array > bulk_th_d[-1]/conv_A_to_nm,dist_array < vap_th_d[-1]/conv_A_to_nm)))) )
                   sq_mean_angle_stddev.append( np.std(angle_arr**2, where=(np.logical_and(np.logical_not(np.isnan(angle_arr)),np.logical_and( dist_array > bulk_th_d[-1]/conv_A_to_nm,dist_array < vap_th_d[-1]/conv_A_to_nm))),ddof=1)/np.sqrt(size_vec) )
                                                                                    
                   #mean_angle,sq_mean_angle
                   #print('shape:',np.shape(np.asarray(cos_theta_list)))
                   if save_data:
                       #file_object5 = open( title+'_'+str(mol_sol)+'_'+size+refer+comment+'_angle.txt', 'a')
                       file_object5 = open( title+'_'+size+refer+comment+'_angle.txt', 'a')
                       file_object5.write('%1.6f \t %1.6f \t %1.6f \t %1.6f \t %1.6f  \n'%(mol_sol,mean_angle[-1],sq_mean_angle[-1],mean_angle_stddev[-1],sq_mean_angle_stddev[-1]))
               else:
                   mean_angle.append( 0 )
                   sq_mean_angle.append( 0 )
                   mean_angle_stddev.append( 0 )
                   sq_mean_angle_stddev.append( 0 )
            else:
               mean_angle.append( 0 )
               sq_mean_angle.append( 0 )
               mean_angle_stddev.append( 0 )
               sq_mean_angle_stddev.append( 0 )
    
    
            ######  Calculation of using the dummy atom method #############################

    
            
            if dummy_atom:

                #atom1 =  u.select_atoms('resid 1')
                #atom_com =  u.select_atoms('resname 3PY5')
                #atom_com = u.select_atoms('resname 3PY5 or resname SOL', updating=True)
                #atoms_COM = atoms.center_of_mass()
                #atom_com = u.select_atoms('sphzone 1 (resname 3PY5 or resname SOL)', updating=True)
                
                
                atom_com = mda.Universe.empty(1,n_residues=1,trajectory=True)
                #atom_com.add_TopologyAttr('resid', list(range(1, 2)))
                atom_com.add_TopologyAttr('resname', ['COM']*1)
                atom_com.dimensions = u.dimensions 
                atom_com.trajectory = u.trajectory
                print(u.dimensions,atom_com.dimensions )
                
                #atom_com = mda.Merge(atom1)
                
                ##atom_com.load_new(universe.trajectory.timeseries(atoms.center_of_mass()), format=MemoryReader)
                ##atom_com.add_TopologyAttr('topol_n30_l12_1.tpr')
                
                coordinates = AnalysisFromFunction(lambda ag: ag.center_of_mass(),
                                                   u.atoms).run().results['timeseries']
                
                
                #with MDAnalysis.Writer("protein.xtc", protein.n_atoms) as W:
                #    for ts in u.trajectory:
                #        W.write(protein)
                
                    #ts.positions = np.array([0.0, 0.0, 0.2])
                
                arr = np.empty((1, u.trajectory.n_frames, 3))
                
                print(atom_com.atoms.positions.shape)
                print(coordinates.shape)
                #for ts in u.trajectory:
                
                for ts in atom_com.trajectory:
                    #arr[:, ts.frame] = atoms.center_of_mass()#compound='residues')
                    #atom_com.atoms.positions[0,:] = atoms.center_of_mass()#compound='residues')
                    #atom_com.atoms.positions[0,:] = coordinates[ts.frame,:]
                
                    atom_com.atoms.translate(coordinates[ts.frame,:]-atom_com.atoms.positions[0,:])
                    #if ts.frame%10000: 
                    #    print('a',ts.time,atom_com.atoms.positions[0,:])
                
                
                    
                    #if ts.frame%10000: print(ts.frame,coordinates[ts.frame,:])
                #for ts in atom_com.trajectory:
                #    if ts.frame%10000: 
                #        print('b',ts.time,atom_com.atoms.positions[0,:])
                
                    
                print(u)
                #    atom_com.atoms.positions[ts.frame,:] = atoms.center_of_mass()#compound='residues')
                
                #print(coordinates.shape)
                #atom_com.load_new(coordinates, format=MemoryReader)
                #atom_com.transfer_to_memory(coordinates)
                
                #atom_com = mda.Universe('topol_n30_l12_1.tpr',np.asarray([[atoms.center_of_mass()]]), format=MemoryReader)
                #atom_com = mda.Universe('topol_n30_l12_1.tpr',coordinates, format=MemoryReader)
                
                #atom_com = mda.Universe(PSF, coordinates, format=MemoryReader, order='afc')
                
                
                #
                #D = DensityAnalysis(atoms)
                #D.run()
                #D.density.convert_density('TIP4P')
                ##D.density.export("water.dx", type="double")
                #D.density.export("solute.dx", type="double") 
                ts = u.trajectory.ts
                
                print(ts.n_atoms)
                print(u.dimensions)
                print(ts.dimensions)
                print(ts.volume)
                
                
                
                dummy_atom_pos=atom_com.select_atoms('resname COM')
                
                print('atoms_wat',atoms_wat)
                print(dummy_atom_pos)
                rdf_wat = InterRDF(g1=dummy_atom_pos,g2=atoms_wat, nbins=100, range=(1, leng_an))
                rdf_wat.run()
                if there_is_solute:
                   print('atoms_sol',atoms_sol)
                   rdf_sol = InterRDF(g1=dummy_atom_pos,g2=atoms_sol, nbins=100, range=(1, leng_an))
                   rdf_sol.run()#start=int(len(u.trajectory[:])/10))
                
                 
                delta_conv = rdf_wat.results.bins[1]-rdf_wat.results.bins[0]
                len_conv = 2*int(n_sigma_smooth*sigma/delta_conv)+1
                gx = np.linspace(-delta_conv*len_conv, delta_conv*len_conv, len_conv ,endpoint=True)
                print('gx:',gx)
                gaussian = np.exp(-(gx/sigma)**2/2)
                gauss_norm= np.trapz(gaussian,dx=delta_conv)/delta_conv
                gauss_norm= float(np.mean(gaussian)*gx.shape[0])
                gaussian = gaussian/gauss_norm
                print('gaussian:',gaussian)
                
                
                
                dens_smooth.append(  np.convolve(gaussian, rdf_wat.results.rdf ,mode='valid') )
                r_smooth = rdf_wat.results.bins[int((len_conv-1)/2):-int((len_conv-1)/2)]
                if there_is_solute:
                   dens_smooth_sol.append(  np.convolve(gaussian, rdf_sol.results.rdf ,mode='valid') )
                   r_smooth_sol = rdf_wat.results.bins[int((len_conv-1)/2):-int((len_conv-1)/2)]
                
                
                #init_gr =  np.argmin(np.abs(dens_smooth-10000))
                    #grady = np.gradient(ndimage.filters.gaussian_filter(dens_cy_w[kk][kfe], [smooth_grad,smooth_grad], mode='constant'))
                
                j = 0
                print( np.abs(np.gradient(dens_smooth[-1],delta_conv)[0]) , tol_grad)
                while np.abs(np.gradient(dens_smooth[-1],delta_conv)[j]) < tol_grad:
                    print( np.abs(np.gradient(dens_smooth[-1],delta_conv)[j]) , tol_grad)
                    j+=1
                
                bulk_th.append( conv_A_to_nm*r_smooth[j] ) #  np.argmin(np.abs(dens_smooth[j][-1] - rdf_wat.results.rdf))
                
                j = len(dens_smooth[-1])-1
                print( 'ff')
                print( np.abs(np.gradient(dens_smooth[-1],delta_conv)[j]) , tol_grad)
                while np.abs(np.gradient(dens_smooth[-1],delta_conv)[j]) < tol_grad:
                    print( np.abs(np.gradient(dens_smooth[-1],delta_conv)[j]) , tol_grad)
                    j-=1
                
                vap_th.append( conv_A_to_nm*r_smooth[j] )
                
                print(len(dens_smooth[-1]),len(r_smooth),len_conv)
                print(len(dens_smooth[-1]*4.0*np.pi*r_smooth**2))
                if sphere:
                   number_wat = np.trapz(dens_smooth[-1]*4.0*np.pi*(r_smooth)**2,x=r_smooth[:])
                elif cylinder:
                   number_wat = np.trapz(dens_smooth[-1]*2.0*np.pi*(r_smooth),x=r_smooth[:])
                else:
                   number_wat = np.trapz(dens_smooth[-1],x=r_smooth[:])
                
                radius_rdf_wat = conv_A_to_nm*rdf_wat.results.bins
                density_wat_rad_rdf.append( conv_Am3_to_nmm3*rdf_wat.results.rdf*len(atoms_wat)/(3.0*number_wat) )
                dens_smooth[-1] = dens_smooth[-1]*len(atoms_wat)/(3.0*number_wat)
                if there_is_solute:
                   if sphere:
                        number_sol = np.trapz(dens_smooth_sol[-1]*4.0*np.pi*(r_smooth_sol)**2,x=r_smooth_sol[:])
                   elif cylinder:
                        number_sol = np.trapz(dens_smooth_sol[-1]*2.0*np.pi*(r_smooth_sol),x=r_smooth_sol[:])
                   else:
                        number_sol = np.trapz(dens_smooth_sol[-1],x=r_smooth_sol[:])
    
                   radius_rdf_sol = conv_A_to_nm*rdf_sol.results.bins
                   density_sol_rad_rdf.append( conv_Am3_to_nmm3*rdf_sol.results.rdf*len(atoms_sol)/(3.0*number_sol) )
                   dens_smooth_sol[-1] = dens_smooth_sol[-1]*len(atoms_sol)/(3.0*number_sol)
    

        if save_data:
            
            file_object = open( title+'_'+str(mol_sol)+'_'+size+refer+comment+'.pkl', 'wb')
      
            if there_is_solute:
                pickle.dump((radius_wat,radius_sol, density_wat_rad, density_sol_rad),file_object,protocol=2)
                if dummy_atom:
                    pickle.dump((radius_rdf_wat, radius_rdf_sol, density_wat_rad_rdf, density_sol_rad_rdf),file_object,protocol=2)
                pickle.dump((r_smooth_d, r_smooth_sol_d, dens_smooth_d, dens_smooth_sol_d),file_object,protocol=2)
                if dummy_atom:
                    pickle.dump((r_smooth, r_smooth_sol, dens_smooth, dens_smooth_sol),file_object,protocol=2)
                    pickle.dump((vap_th,bulk_th),file_object,protocol=2)
                pickle.dump((vap_th_d,bulk_th_d),file_object,protocol=2)
                pickle.dump((time_vec,com_coord_vec),file_object,protocol=2)
            else:
                pickle.dump((radius_wat, density_wat_rad),file_object,protocol=2)
                if dummy_atom:
                    pickle.dump((radius_rdf_wat,  density_wat_rad_rdf),file_object,protocol=2)
                pickle.dump((r_smooth_d, dens_smooth_d),file_object,protocol=2)
                if dummy_atom:
                    pickle.dump((r_smooth, dens_smooth),file_object,protocol=2)
                    pickle.dump((vap_th,bulk_th),file_object,protocol=2)
                pickle.dump((vap_th_d,bulk_th_d),file_object,protocol=2)
                pickle.dump((time_vec,com_coord_vec),file_object,protocol=2)
      
            file_object.close()
    
    
    else:
        ifile = open( title+'_'+str(mol_sol)+'_'+size+refer+comment+'.pkl', 'rb')

        if there_is_solute:
           (radius_wat,radius_sol, density_wat_rad, density_sol_rad)   =  pickle.load(ifile) 
           if dummy_atom:
                (radius_rdf_wat,radius_rdf_sol, density_wat_rad_rdf, density_sol_rad_rdf ) =  pickle.load(ifile) 
           (r_smooth_d, r_smooth_sol_d, dens_smooth_d, dens_smooth_sol_d) =  pickle.load(ifile) 
           if dummy_atom:
                (r_smooth, r_smooth_sol, dens_smooth, dens_smooth_sol) =  pickle.load(ifile) 
                (vap_th,bulk_th) =  pickle.load(ifile) 
           (vap_th_d,bulk_th_d) =  pickle.load(ifile) 
           (time_vec,com_coord_vec) = pickle.load(ifile)
        else:
           (radius_wat, density_wat_rad)   =  pickle.load(ifile) 
           if dummy_atom:
               (radius_rdf_wat, density_wat_rad_rdf) =  pickle.load(ifile) 
           (r_smooth_d,  dens_smooth_d) =  pickle.load(ifile) 
           if dummy_atom:
               (r_smooth, dens_smooth) =  pickle.load(ifile) 
               (vap_th,bulk_th) =  pickle.load(ifile) 
           (vap_th_d,bulk_th_d) =  pickle.load(ifile) 
           (time_vec,com_coord_vec) = pickle.load(ifile)
    
        ifile.close()

        mean_angle = [0]*n_blocks
        sq_mean_angle =  [0]*n_blocks
        mean_angle_stddev =  [0]*n_blocks
        sq_mean_angle_stddev =  [0]*n_blocks


        #delta_conv = radius_rdf_wat[1]-radius_rdf_wat[0]
        #len_conv = 2*int(n_sigma_smooth*sigma/delta_conv)+1
    
        #r_smooth = radius_rdf_wat[int((len_conv-1)/2):-int((len_conv-1)/2)]
        #if there_is_solute:
        #    r_smooth_sol = radius_rdf_sol[int((len_conv-1)/2):-int((len_conv-1)/2)]
        #gx = np.linspace(-delta_conv*len_conv, delta_conv*len_conv, len_conv ,endpoint=True)
        #print('gx:',gx)
        #gaussian = np.exp(-(gx/sigma)**2/2)
        #gauss_norm= np.trapz(gaussian,dx=delta_conv)/delta_conv
        #gauss_norm= float(np.mean(gaussian)*gx.shape[0])
        #gaussian = gaussian/gauss_norm
        #print('gaussian:',gaussian)
    
     
    
    
    #volume = 4.0*(conv_A_to_nm*rdf_sol.results.bins)**3/3.0
    
    
    density_wat_rad_mean = np.mean(np.asarray(density_wat_rad),axis = 0)      
    density_wat_rad_std = np.std(np.asarray(density_wat_rad),axis = 0,ddof=1)      
    dens_smooth_d_mean  = np.mean(np.asarray( dens_smooth_d),axis = 0)      
    dens_smooth_d_std  = np.std(np.asarray( dens_smooth_d),axis = 0,ddof=1)      
    vap_th_d_mean = np.mean(np.asarray(vap_th_d),axis = 0)      
    vap_th_d_std = np.std(np.asarray(vap_th_d),axis = 0,ddof=1)      
    
    vap_th_mean = np.mean(np.asarray(vap_th),axis = 0)      
    vap_th_std = np.std(np.asarray(vap_th),axis = 0,ddof=1)      
    bulk_th_d_mean = np.mean(np.asarray(bulk_th_d),axis = 0)      
    bulk_th_d_std = np.std(np.asarray(bulk_th_d),axis = 0,ddof=1)      
    
    if dummy_atom:
        density_wat_rad_rdf_mean = np.mean(np.asarray(density_wat_rad_rdf),axis = 0)      
        density_wat_rad_rdf_std = np.std(np.asarray(density_wat_rad_rdf),axis = 0,ddof=1)      
        dens_smooth_mean = np.mean(np.asarray(dens_smooth),axis = 0)      
        dens_smooth_std = np.std(np.asarray(dens_smooth),axis = 0,ddof=1)      
        bulk_th_mean = np.mean(np.asarray(bulk_th),axis = 0)      
        bulk_th_std = np.std(np.asarray(bulk_th),axis = 0,ddof=1)      
    
    
    if there_is_solute:
        density_sol_rad_mean = np.mean(np.asarray(density_sol_rad),axis = 0)      
        dens_smooth_sol_d_mean = np.mean(np.asarray(dens_smooth_sol_d),axis = 0)      
        density_sol_rad_std = np.std(np.asarray(density_sol_rad),axis = 0,ddof=1)      
        dens_smooth_sol_d_std = np.std(np.asarray(dens_smooth_sol_d),axis = 0,ddof=1)      
        if dummy_atom:
            density_sol_rad_rdf_mean = np.mean(np.asarray(density_sol_rad_rdf),axis = 0)      
            density_sol_rad_rdf_std = np.std(np.asarray(density_sol_rad_rdf),axis = 0,ddof=1)      
            dens_smooth_sol_mean = np.mean(np.asarray(dens_smooth_sol),axis = 0)      
            dens_smooth_sol_std = np.std(np.asarray(dens_smooth_sol),axis = 0,ddof=1)      
    
    
    
    #print('nframes, number_wat:',u.trajectory.n_frames,number_wat,len(atoms_wat),number_wat/(3.0*u.trajectory.n_frames))#len(atoms_wat)*
    #print('n:',density_wat_rad_rdf_mean*len(atoms_wat)/(3.0*number_wat))#*u.trajectory.n_frames))#
     
    #if there_is_solute:
    #    fig = plt.figure()
    #    plt.plot(radius_rdf_sol, density_sol_rad_rdf[-1]*len(atoms_sol)/(3.0*number_sol),'-')
    #    plt.xlabel('r ($\mathrm{nm}$)')
    #    plt.ylabel('c ($\mathrm{nm}^{-3}$)')
    #    if save_figure:
    #        plt.savefig('density_gdf_sol.pdf')
    #        plt.close()
    #    else:
    #        plt.show()
    #
    
    
    #print(radius_rdf_wat, density_wat_rad_rdf_mean)
    
    rmin = 0.5
    rmax = 1.5
    
    if analyze_densities and dummy_atom:
        g_fit_1, g_cov_1 = curve_fit( lambda x, a,c: x*a+c,radius_rdf_wat[ np.logical_and( radius_rdf_wat <rmax ,radius_rdf_wat >=rmin)] , density_wat_rad_rdf_mean[ np.logical_and( radius_rdf_wat <rmax , radius_rdf_wat >=rmin)]*len(atoms_wat)/(3.0*number_wat)  ,p0=[1.0,1.0])
    
        print(g_fit_1, g_cov_1)
    
    if dummy_atom:
        fig = plt.figure()
        
        plt.plot(radius_rdf_wat ,  density_wat_rad_rdf_mean,'--')
        
        plt.plot(conv_A_to_nm*r_smooth, conv_Am3_to_nmm3*dens_smooth_mean,'.')
        plt.plot([bulk_th_mean,bulk_th_mean],[0,conv_Am3_to_nmm3*dens_smooth_mean[10]],'-')
        plt.plot([vap_th_mean,vap_th_mean],[0,conv_Am3_to_nmm3*dens_smooth_mean[10]],'-')
        
        x = np.arange(rmin, rmax , (rmax-rmin)/100.0)
        if analyze_densities:
             plt.plot(x,(x*g_fit_1[0]+g_fit_1[1]),'-')
        #plt.ylim(11000,11500)
        plt.xlabel('r ($\mathrm{nm}$)')
        plt.ylabel('c ($\mathrm{nm}^{-3}$)')
        if save_figure:
           plt.savefig('density_rdf_wat_'+title+'_'+str(mol_sol)+'_'+size+refer+comment+'.pdf')
           plt.close()
        else:
           plt.show()
        
        
        
        if there_is_solute:
           fig = plt.figure()
           plt.plot(radius_rdf_wat , density_sol_rad_rdf_mean,'-')
           plt.plot([bulk_th_mean,bulk_th_mean],[0,conv_Am3_to_nmm3*dens_smooth_mean[10]],'-')
           plt.plot([vap_th_mean,vap_th_mean],[0,conv_Am3_to_nmm3*dens_smooth_mean[10]],'-')
           #plt.ylim(0,3000)
           plt.xlabel('r ($\mathrm{nm}$)')
           plt.ylabel('c ($\mathrm{nm}^{-3}$)')
           plt.savefig('density_rdf_sol_'+title+'_'+str(mol_sol)+'_'+size+refer+comment+'.pdf')
           plt.close()
        
        
       # Extract the COM of the solute
       #atoms_COM = atoms.center_of_mass()
       #solute_density = DensityAnalysis(atoms, delta=1.0,
       #                                      select='resname 3PY5',
       #                                      update_selection=True,
       #                                      gridcenter=solute_COM,
       #                                      xdim=30.0, ydim=30.0, zdim=30.0)
       
       
       
    if there_is_solute:
       fig = plt.figure()
       plt.plot(radius_sol,density_sol_rad_mean,'-')
       plt.plot([bulk_th_d_mean,bulk_th_d_mean],[0,np.amax(density_sol_rad_mean)],'-')
       plt.plot([vap_th_d_mean,vap_th_d_mean],[0,np.amax(density_sol_rad_mean)],'-')
       
       plt.xlabel('r ($\mathrm{nm}$)')
       plt.ylabel('c ($\mathrm{nm}^{-3}$)')
       plt.savefig('density_sol_'+title+'_'+str(mol_sol)+'_'+size+refer+comment+'.pdf')
       plt.close()
    
    fig = plt.figure()
    plt.plot(radius_wat,density_wat_rad_mean,'-')
    #print('wat',)
    #print('n',np.trapz(conv_Am3_to_nmm3*np.convolve(gaussian, counts_wat ,mode='valid')*4.0*np.pi*(conv_A_to_nm*lengths_wat[int((len_conv-1)/2):-int((len_conv-1)/2)-1])**2,x=conv_A_to_nm*lengths_wat[int((len_conv-1)/2):-int((len_conv-1)/2)-1]))
    #print(conv_Am3_to_nmm3*np.convolve(gaussian, counts_wat ,mode='valid')*4.0*np.pi*(conv_A_to_nm*lengths_wat[int((len_conv-1)/2):-int((len_conv-1)/2)-1])**2)
    
    plt.plot(conv_A_to_nm*r_smooth_d,conv_Am3_to_nmm3*dens_smooth_d_mean,'.')
    plt.plot([bulk_th_d_mean,bulk_th_d_mean],[0,conv_Am3_to_nmm3*dens_smooth_d_mean[10]],'-')
    plt.plot([vap_th_d_mean,vap_th_d_mean],[0,conv_Am3_to_nmm3*dens_smooth_d_mean[10]],'-')
    
    #if analyze_densities:
    #    plt.plot(conv_A_to_nm*lengths_wat[int((len_conv-1)/2):-int((len_conv-1)/2)-1],conv_Am3_to_nmm3*np.convolve(gaussian, counts_wat ,mode='valid'),'--')#*4.0*np.pi*(conv_A_to_nm*lengths_wat[int((len_conv-1)/2):-int((len_conv-1)/2)-1])**2,dx=))
    plt.xlabel('r ($\mathrm{nm}$)')
    plt.ylabel('c ($\mathrm{nm}^{-3}$)')
    plt.savefig('density_wat_'+title+'_'+str(mol_sol)+'_'+size+refer+comment+'.pdf')
    plt.close()
    
    for kj in range(0,len(density_wat_rad)):
        col = ((kj)/len(density_wat_rad),0.4, (kj)/len(density_wat_rad))
        plt.plot(radius_wat,density_wat_rad[kj],color=colors.to_hex(col),linestyle='-')
        #plt.plot(conv_A_to_nm*r_smooth_d,conv_Am3_to_nmm3*dens_smooth_d[kj],'.')
    plt.plot([bulk_th_d_mean,bulk_th_d_mean],[0,conv_Am3_to_nmm3*dens_smooth_d_mean[10]],'-')
    plt.plot([vap_th_d_mean,vap_th_d_mean],[0,conv_Am3_to_nmm3*dens_smooth_d_mean[10]],'-')
    
    #if analyze_densities:
    #    plt.plot(conv_A_to_nm*lengths_wat[int((len_conv-1)/2):-int((len_conv-1)/2)-1],conv_Am3_to_nmm3*np.convolve(gaussian, counts_wat ,mode='valid'),'--')#*4.0*np.pi*(conv_A_to_nm*lengths_wat[int((len_conv-1)/2):-int((len_conv-1)/2)-1])**2,dx=))
    plt.xlabel('r ($\mathrm{nm}$)')
    plt.ylabel('c ($\mathrm{nm}^{-3}$)')
    if save_figure:
       plt.savefig('density_wat_realiz_'+title+'_'+str(mol_sol)+'_'+size+refer+'.pdf')
       plt.close()
    else:
       plt.show()
    
    
    fig = plt.figure()
    if there_is_solute:
        plt.plot(radius_sol,density_sol_rad_mean,'-')
    plt.plot(radius_wat,density_wat_rad_mean,'--')
    plt.xlabel('r ($\mathrm{nm}$)')
    plt.ylabel('c ($\mathrm{nm}^{-3}$)')
    plt.yscale("log")
    plt.savefig('densities_log_'+title+'_'+str(mol_sol)+'_'+size+refer+comment+'.pdf')
    plt.close()
    
    if data_analysis:
    
        if save_data:
            file_object2 = open( title+'_'+size+refer+comment+'.txt', 'a')
            file_object3 = open( title+'_'+size+refer+comment+'_blocks.txt', 'a')
            file_object4 = open( title+'_'+size+refer+comment+'_mean.txt', 'a')
    
        arr= radius_wat[radius_wat<vap_th_d_mean]
        arr2= density_wat_rad_mean[radius_wat<vap_th_d_mean]
    r_interf = arr[arr>bulk_th_d_mean]
    dens_w_interf = arr2[arr>bulk_th_d_mean]

    if sphere: 
        integ_dens_w_interf = np.trapz(dens_w_interf*4.0*np.pi*r_interf**2,x=r_interf)
    elif cylinder: 
        integ_dens_w_interf = np.trapz(dens_w_interf*2.0*np.pi*r_interf,x=r_interf)
    else:
        integ_dens_w_interf = np.trapz(dens_w_interf,x=r_interf)

    r_bulk= radius_wat[radius_wat<bulk_th_d_mean]
    r_vapo= radius_wat[radius_wat>vap_th_d_mean]

    dens_w_bulk= density_wat_rad_mean[radius_wat<bulk_th_d_mean]
    dens_w_vapo= density_wat_rad_mean[radius_wat>vap_th_d_mean]

    if sphere: 
       integ_dens_w_bulk = np.trapz(dens_w_bulk*4.0*np.pi*r_bulk**2,x=r_bulk)
       integ_dens_w_vapo = np.trapz(dens_w_vapo*4.0*np.pi*r_vapo**2,x=r_vapo)
       
       av_dens_w_bulk = integ_dens_w_bulk*3.0/(4.0*np.pi*r_bulk[-1]**3)
       av_dens_w_vapo = integ_dens_w_vapo*3.0/(4.0*np.pi*(r_vapo[-1]**3-r_vapo[0]**3))
       
       #i_gds_pos =  (np.abs( av_dens_w_bulk*4.0*np.pi*(r_interf**3-r_interf[0]**3)/3.0 - integ_dens_w_interf )).argmin()  
       i_gds_pos =  (np.abs( av_dens_w_bulk*4.0*np.pi*(r_interf**3-r_interf[0]**3)/3.0 +av_dens_w_vapo*4.0*np.pi*(r_interf[-1]**3-r_interf**3)/3.0 - integ_dens_w_interf )).argmin()  
    elif cylinder: 
       integ_dens_w_bulk = np.trapz(dens_w_bulk*2.0*np.pi*r_bulk,x=r_bulk)
       integ_dens_w_vapo = np.trapz(dens_w_vapo*2.0*np.pi*r_vapo,x=r_vapo)
       
       av_dens_w_bulk = integ_dens_w_bulk/(np.pi*r_bulk[-1]**2)
       av_dens_w_vapo = integ_dens_w_vapo/(np.pi*(r_vapo[-1]**2-r_vapo[0]**2))
       
       #i_gds_pos =  (np.abs( av_dens_w_bulk*np.pi*(r_interf**2-r_interf[0]**2) - integ_dens_w_interf )).argmin()  
       i_gds_pos =  (np.abs( av_dens_w_bulk*np.pi*(r_interf**2-r_interf[0]**2)+ av_dens_w_vapo * np.pi*(r_interf[-1]**2-r_interf**2)- integ_dens_w_interf )).argmin()  
    else:
       integ_dens_w_bulk = np.trapz(dens_w_bulk,x=r_bulk)
       integ_dens_w_vapo = np.trapz(dens_w_vapo,x=r_vapo)
       
       av_dens_w_bulk = integ_dens_w_bulk/(r_bulk[-1])
       av_dens_w_vapo = integ_dens_w_vapo/((r_vapo[-1]-r_vapo[0]))
       
       i_gds_pos =  (np.abs( av_dens_w_bulk*(r_interf-r_interf[0])+ av_dens_w_vapo * (r_interf[-1]-r_interf)- integ_dens_w_interf )).argmin()  

    r_gds_pos =  r_interf[i_gds_pos]

    if there_is_solute:
        arr= radius_sol[radius_sol<vap_th_d_mean]
        r_interf_sol = arr[arr>bulk_th_d_mean]
        arr2= density_sol_rad_mean[radius_sol<vap_th_d_mean]
        dens_sol_interf = arr2[arr>bulk_th_d_mean]

        if sphere: 
            integ_dens_sol_interf = np.trapz(dens_sol_interf*4.0*np.pi*r_interf_sol**2,x=r_interf_sol)
        elif cylinder: 
            integ_dens_sol_interf = np.trapz(dens_sol_interf*2.0*np.pi*r_interf_sol,x=r_interf_sol)
        else:
            integ_dens_sol_interf = np.trapz(dens_sol_interf,x=r_interf_sol)

        r_bulk_sol = radius_sol[radius_sol<bulk_th_d_mean]
        r_vapo_sol = radius_sol[radius_sol>vap_th_d_mean]

        dens_sol_bulk= density_sol_rad_mean[radius_sol<bulk_th_d_mean]
        dens_sol_vapo= density_sol_rad_mean[radius_sol>vap_th_d_mean]

        if sphere: 
            integ_dens_sol_bulk = np.trapz(dens_sol_bulk*4.0*np.pi*r_bulk_sol**2,x=r_bulk_sol)
            integ_dens_sol_vapo = np.trapz(dens_sol_vapo*4.0*np.pi*r_vapo_sol**2,x=r_vapo_sol)

            av_dens_sol_bulk = integ_dens_sol_bulk*3.0/(4.0*np.pi*r_bulk_sol[-1]**3)
            av_dens_sol_vapo = integ_dens_sol_vapo*3.0/(4.0*np.pi*(r_vapo_sol[-1]**3-r_vapo_sol[0]**3))

            #excess_dens_interf = (integ_dens_sol_interf - av_dens_sol_bulk * 4.0*np.pi*(r_gds_pos**3-r_interf_sol[0]**3)/3.0)/(4.0*np.pi*r_gds_pos**2)
            excess_dens_interf = (integ_dens_sol_interf - av_dens_sol_bulk * 4.0*np.pi*(r_gds_pos**3-r_interf_sol[0]**3)/3.0  - av_dens_sol_vapo* 4.0*np.pi*(r_interf_sol[-1]**3-r_gds_pos**3)/3.0)/(4.0*np.pi*r_gds_pos**2)
        elif cylinder: 
            integ_dens_sol_bulk = np.trapz(dens_sol_bulk*2.0*np.pi*r_bulk_sol,x=r_bulk_sol)
            integ_dens_sol_vapo = np.trapz(dens_sol_vapo*2.0*np.pi*r_vapo_sol,x=r_vapo_sol)

            av_dens_sol_bulk = integ_dens_sol_bulk/(np.pi*r_bulk_sol[-1]**2)
            av_dens_sol_vapo = integ_dens_sol_vapo/(np.pi*(r_vapo_sol[-1]**2-r_vapo_sol[0]**2))
 
            #excess_dens_interf = (integ_dens_sol_interf - av_dens_sol_bulk * np.pi*(r_gds_pos**2-r_interf_sol[0]**2))/(2.0*np.pi*r_gds_pos)
            excess_dens_interf = (integ_dens_sol_interf - av_dens_sol_bulk * np.pi*(r_gds_pos**2-r_interf_sol[0]**2) - av_dens_sol_vapo * np.pi*(r_interf_sol[-1]**2-r_gds_pos**2) )/(2.0*np.pi*r_gds_pos)
        else:
            integ_dens_sol_bulk = np.trapz(dens_sol_bulk,x=r_bulk_sol)
            integ_dens_sol_vapo = np.trapz(dens_sol_vapo,x=r_vapo_sol)

            av_dens_sol_bulk = integ_dens_sol_bulk/(r_bulk_sol[-1])
            av_dens_sol_vapo = integ_dens_sol_vapo/((r_vapo_sol[-1]-r_vapo_sol[0]))
 
            excess_dens_interf = (integ_dens_sol_interf - av_dens_sol_bulk *(r_gds_pos-r_interf_sol[0]) - av_dens_sol_vapo *(r_interf_sol[-1]-r_gds_pos) )

        if save_data:
            file_object2.write('%1.6f \t %1.6f \t %1.6f \t %1.6f \t %1.6f \t %1.6f \t %1.6f \t %1.6f \t %1.6f \n'%(mol_sol,bulk_th_d_mean,vap_th_d_mean,r_gds_pos,av_dens_w_bulk,av_dens_sol_bulk,excess_dens_interf,av_dens_sol_vapo,av_dens_w_vapo))
    else:
        if save_data:
            file_object2.write('%1.6f \t %1.6f \t %1.6f \t %1.6f \t %1.6f \t %1.6f \n'%(mol_sol,bulk_th_d_mean,vap_th_d_mean,r_gds_pos,av_dens_w_bulk,av_dens_w_vapo))
    if save_data:
        file_object2.close()

    excess_dens_interf_vec = []
    av_dens_sol_bulk_vec = []
    av_dens_sol_vapo_vec = []
    av_dens_w_bulk_vec = []
    av_dens_w_vapo_vec = []
    r_gds_pos_vec = []
    surf_tens_vec = []

    for jj in range(0,n_blocks):
       arr= radius_wat[radius_wat<vap_th_d[jj]]
       arr2= density_wat_rad[jj][radius_wat<vap_th_d[jj]]
       r_interf = arr[arr>bulk_th_d[jj]]
       dens_w_interf = arr2[arr>bulk_th_d[jj]]
       
       if sphere: 
           integ_dens_w_interf = np.trapz(dens_w_interf*4.0*np.pi*r_interf**2,x=r_interf)
       elif cylinder:
           integ_dens_w_interf = np.trapz(dens_w_interf*2.0*np.pi*r_interf,x=r_interf)
       else:
           integ_dens_w_interf = np.trapz(dens_w_interf,x=r_interf)
       
       r_bulk= radius_wat[radius_wat<bulk_th_d[jj]]
       r_vapo= radius_wat[radius_wat>vap_th_d[jj]]

       dens_w_bulk= density_wat_rad[jj][radius_wat<bulk_th_d[jj]]
       dens_w_vapo= density_wat_rad[jj][radius_wat>vap_th_d[jj]]
       
       if sphere: 
          integ_dens_w_bulk = np.trapz(dens_w_bulk*4.0*np.pi*r_bulk**2,x=r_bulk)
          integ_dens_w_vapo = np.trapz(dens_w_vapo*4.0*np.pi*r_vapo**2,x=r_vapo)
          
          av_dens_w_bulk_vec.append(integ_dens_w_bulk*3.0/(4.0*np.pi*r_bulk[-1]**3))
          av_dens_w_vapo_vec.append(integ_dens_w_vapo*3.0/(4.0*np.pi*(r_vapo[-1]**3-r_vapo[0]**3)))

          #i_gds_pos =  (np.abs( av_dens_w_bulk_vec[-1]*4.0*np.pi*(r_interf**3-r_interf[0]**3)/3.0 - integ_dens_w_interf )).argmin()  
          i_gds_pos =  (np.abs( av_dens_w_bulk_vec[-1]*4.0*np.pi*(r_interf**3-r_interf[0]**3)/3.0 + av_dens_w_vapo_vec[-1]*4.0*np.pi*(r_interf[-1]**3-r_interf**3)/3.0 - integ_dens_w_interf )).argmin()  
       elif cylinder:
          integ_dens_w_bulk = np.trapz(dens_w_bulk*2.0*np.pi*r_bulk,x=r_bulk)
          integ_dens_w_vapo = np.trapz(dens_w_vapo*2.0*np.pi*r_vapo,x=r_vapo)
          
          av_dens_w_bulk_vec.append(integ_dens_w_bulk/(np.pi*r_bulk[-1]**2))
          av_dens_w_vapo_vec.append(integ_dens_w_vapo/(np.pi*(r_vapo[-1]**2-r_vapo[0]**2)))
          
          #i_gds_pos =  (np.abs( av_dens_w_bulk_vec[-1]*np.pi*(r_interf**2-r_interf[0]**2) - integ_dens_w_interf )).argmin()  
          i_gds_pos =  (np.abs( av_dens_w_bulk_vec[-1]*np.pi*(r_interf**2-r_interf[0]**2)+ av_dens_w_vapo_vec[-1] *np.pi*(r_interf[-1]**2-r_interf**2) - integ_dens_w_interf )).argmin()  

       else:
          integ_dens_w_bulk = np.trapz(dens_w_bulk,x=r_bulk)
          integ_dens_w_vapo = np.trapz(dens_w_vapo,x=r_vapo)
          
          av_dens_w_bulk_vec.append(integ_dens_w_bulk/(r_bulk[-1]))
          av_dens_w_vapo_vec.append(integ_dens_w_vapo/((r_vapo[-1]-r_vapo[0])))
          
          #i_gds_pos =  (np.abs( av_dens_w_bulk_vec[-1]*np.pi*(r_interf**2-r_interf[0]**2) - integ_dens_w_interf )).argmin()  
          i_gds_pos =  (np.abs( av_dens_w_bulk_vec[-1]*(r_interf-r_interf[0])+ av_dens_w_vapo_vec[-1] *(r_interf[-1]-r_interf) - integ_dens_w_interf )).argmin()  
       
       r_gds_pos_vec.append( r_interf[i_gds_pos] )

       if calc_virial:                  
            if sphere: 
                surf_tens_vec.append( conv_kJsumolAng_mN*conv_A_m*(2.0*virial_3d[jj][1]-(virial_3d[jj][0]+virial_3d[jj][2]))/(np.pi*conv_nm_m*r_gds_pos_vec[-1]*conv_A_m*u.dimensions[1]) )
            else:
                surf_tens_vec.append( conv_kJsumolAng_mN*conv_A_m*(2.0*virial_3d[jj][1]-(virial_3d[jj][0]+virial_3d[jj][2]))/(np.pi*conv_nm_m*r_gds_pos_vec[-1]*conv_A_m*u.dimensions[1]) )
       else:
                surf_tens_vec.append( 0.0 )


       if there_is_solute:
           arr= radius_sol[radius_sol<vap_th_d[jj]]
           r_interf_sol = arr[arr>bulk_th_d[jj]]
           arr2= density_sol_rad[jj][radius_sol<vap_th_d[jj]]
           dens_sol_interf = arr2[arr>bulk_th_d[jj]]
       
           if sphere: 
               integ_dens_sol_interf = np.trapz(dens_sol_interf*4.0*np.pi*r_interf_sol**2,x=r_interf_sol)
           elif cylinder:
               integ_dens_sol_interf = np.trapz(dens_sol_interf*2.0*np.pi*r_interf_sol,x=r_interf_sol)
           else:
               integ_dens_sol_interf = np.trapz(dens_sol_interf,x=r_interf_sol)
       
           r_bulk_sol = radius_sol[radius_sol<bulk_th_d[jj]]
           r_vapo_sol = radius_sol[radius_sol>vap_th_d[jj]]
       
           dens_sol_bulk= density_sol_rad[jj][radius_sol<bulk_th_d[jj]]
           dens_sol_vapo= density_sol_rad[jj][radius_sol>vap_th_d[jj]]
       
           if sphere: 
               integ_dens_sol_bulk = np.trapz(dens_sol_bulk*4.0*np.pi*r_bulk_sol**2,x=r_bulk_sol)
               integ_dens_sol_vapo = np.trapz(dens_sol_vapo*4.0*np.pi*r_vapo_sol**2,x=r_vapo_sol)
       
               av_dens_sol_bulk_vec.append( integ_dens_sol_bulk*3.0/(4.0*np.pi*r_bulk_sol[-1]**3) )
               av_dens_sol_vapo_vec.append( integ_dens_sol_vapo*3.0/(4.0*np.pi*(r_vapo_sol[-1]**3-r_vapo_sol[0]**3)) )
       
               #excess_dens_interf_vec.append((integ_dens_sol_interf - av_dens_sol_bulk_vec[-1] * 4.0*np.pi*(r_gds_pos_vec[-1]**3-r_interf_sol[0]**3)/3.0)/(4.0*np.pi*r_gds_pos_vec[-1]**2))
               excess_dens_interf_vec.append((integ_dens_sol_interf - av_dens_sol_bulk_vec[-1] * 4.0*np.pi*(r_gds_pos_vec[-1]**3-r_interf_sol[0]**3)/3.0- av_dens_sol_vapo_vec[-1] * 4.0*np.pi*(r_interf_sol[-1]**3-r_gds_pos_vec[-1]**3)//3.0)/(4.0*np.pi*r_gds_pos_vec[-1]**2))
           elif cylinder:
               integ_dens_sol_bulk = np.trapz(dens_sol_bulk*2.0*np.pi*r_bulk_sol,x=r_bulk_sol)
               integ_dens_sol_vapo = np.trapz(dens_sol_vapo*2.0*np.pi*r_vapo_sol,x=r_vapo_sol)
       
               av_dens_sol_bulk_vec.append(integ_dens_sol_bulk/(np.pi*r_bulk_sol[-1]**2))
               av_dens_sol_vapo_vec.append(integ_dens_sol_vapo/(np.pi*(r_vapo_sol[-1]**2-r_vapo_sol[0]**2)))
       
               #excess_dens_interf_vec.append((integ_dens_sol_interf - av_dens_sol_bulk_vec[-1] * np.pi*(r_gds_pos_vec[-1]**2-r_interf_sol[0]**2))/(2.0*np.pi*r_gds_pos_vec[-1]))
               excess_dens_interf_vec.append((integ_dens_sol_interf - av_dens_sol_bulk_vec[-1] * np.pi*(r_gds_pos_vec[-1]**2-r_interf_sol[0]**2)- av_dens_sol_vapo_vec[-1] * np.pi*(r_interf_sol[-1]**2-r_gds_pos_vec[-1]**2))/(2.0*np.pi*r_gds_pos_vec[-1]))
           else:
               integ_dens_sol_bulk = np.trapz(dens_sol_bulk,x=r_bulk_sol)
               integ_dens_sol_vapo = np.trapz(dens_sol_vapo,x=r_vapo_sol)
       
               av_dens_sol_bulk_vec.append(integ_dens_sol_bulk/(r_bulk_sol[-1]))
               av_dens_sol_vapo_vec.append(integ_dens_sol_vapo/((r_vapo_sol[-1]-r_vapo_sol[0])))
       
               excess_dens_interf_vec.append((integ_dens_sol_interf - av_dens_sol_bulk_vec[-1] *(r_gds_pos_vec[-1]-r_interf_sol[0])- av_dens_sol_vapo_vec[-1] *(r_interf_sol[-1]-r_gds_pos_vec[-1])))
       


           if save_data:
               file_object3.write('%1.6f \t %1.6f \t %1.6f \t %1.6f \t %1.6f \t %1.6f \t %1.6f \t %1.6f \t %1.6f \t %1.6f \t %1.6f \t %1.6f \t %1.6f \t %1.6f \n'%(mol_sol,bulk_th_d[jj],vap_th_d[jj],r_gds_pos_vec[-1],av_dens_w_bulk_vec[-1],av_dens_sol_bulk_vec[-1],excess_dens_interf_vec[-1],mean_angle[jj],sq_mean_angle[jj],mean_angle_stddev[jj],sq_mean_angle_stddev[jj],av_dens_w_vapo_vec[-1],av_dens_sol_vapo_vec[-1],surf_tens_vec[-1]))
       else:
           if save_data:
               file_object3.write('%1.6f \t %1.6f \t %1.6f \t %1.6f \t %1.6f \t %1.6f \t %1.6f \t %1.6f \t %1.6f \t %1.6f \t %1.6f \n'%(mol_sol,bulk_th_d[jj],vap_th_d[jj],r_gds_pos_vec[-1],av_dens_w_bulk_vec[-1],mean_angle[jj],sq_mean_angle[jj],mean_angle_stddev[jj],sq_mean_angle_stddev[jj],av_dens_w_vapo_vec[-1],surf_tens_vec[-1]))
    if save_data:
        file_object3.close()


    if save_data:
        if there_is_solute:
            file_object4.write('%1.6f \t %1.6f \t %1.6f \t %1.6f \t %1.6f \t %1.6f \t %1.6f \t %1.6f \t %1.6f \t %1.6f \t %1.6f \t %1.6f \t %1.6f \t %1.6f \t %1.6f \t %1.6f \t %1.6f \t %1.6f \t %1.6f \n'%(mol_sol,np.mean(bulk_th_d),np.mean(vap_th_d),np.mean(r_gds_pos_vec),np.mean(av_dens_w_bulk_vec),np.mean(av_dens_sol_bulk_vec),np.mean(excess_dens_interf_vec),np.std(bulk_th_d, ddof=1),np.std(vap_th_d, ddof=1),np.std(r_gds_pos_vec, ddof=1),np.std(av_dens_w_bulk_vec, ddof=1),np.std(av_dens_sol_bulk_vec, ddof=1),np.std(excess_dens_interf_vec, ddof=1),np.mean(av_dens_w_vapo_vec),np.mean(av_dens_sol_vapo_vec),np.std(av_dens_w_vapo_vec, ddof=1),np.std(av_dens_sol_vapo_vec, ddof=1),np.mean(surf_tens_vec),np.std(surf_tens_vec, ddof=1)))
        else:
            file_object4.write('%1.6f \t %1.6f \t %1.6f \t %1.6f \t %1.6f \t %1.6f \t %1.6f \t %1.6f \t %1.6f \t %1.6f \t %1.6f \t %1.6f \t %1.6f \n'%(mol_sol,np.mean(bulk_th_d),np.mean(vap_th_d),np.mean(r_gds_pos_vec),np.mean(av_dens_w_bulk_vec),np.std(bulk_th_d, ddof=1),np.std(vap_th_d, ddof=1),np.std(r_gds_pos_vec, ddof=1),np.std(av_dens_w_bulk_vec, ddof=1),np.mean(av_dens_w_vapo_vec),np.std(av_dens_w_vapo_vec, ddof=1),np.mean(surf_tens_vec),np.std(surf_tens_vec, ddof=1)))

        file_object4.close()





gc.collect()


exit()
    
    
    
    
    
#).trajectory[2]

#print([int(ts.time) for ts in u.trajectory])


g = Grid("water.dx")


#dx = OpenDX.field(0)
#dx.read('solute.dx')

print(g.grid.shape)

print('0')
#fig = plt.figure(constrained_layout=True)
fig = plt.figure()
print('1')
ax = fig.add_subplot(111)

#x, y = np.mgrid[:dens_cy_sol_aver[0].shape[0], :dens_cy_sol_aver[0].shape[1]]
#ax.plot(points_x*curve[-1].shape[0],points_y*curve[-1].shape[1],'k')

#ax.plot(xi_int2,yi_int2, 'y-.')

print('2')
#ax.quiver(x[::10,::10], y[::10,::10], gradx[::10,::10], grady[::10,::10], color='k', units='xy', scale=1)
plt.imshow(np.transpose(g.grid[:,:,40]),aspect='auto' ,  origin='lower',# extent=[0, boxx, 0, boxy],
           cmap='RdGy', alpha=0.5)
plt.colorbar()
#ax.plot(xi[-1],yi[-1], 'm')
print('3')
ax.contour(np.transpose(g.grid[:,:,40]),[0.02], colors='r')
#ax.plot(xc_0+R_0*np.cos(tetha_0), yc_0+R_0*np.sin(tetha_0) ,'b--')

print('4')


#plt.scatter(xy_in_int[:,:,0],xy_in_int[:,:,1])
plt.gca().set_aspect('equal', adjustable='box')
plt.xlabel(r'$x$ (nm)', fontsize=fnt_sz)
plt.ylabel(r'$y$ (nm)', fontsize=fnt_sz)

#plt.ylim(0.0,boxy)
#plt.xlim(0.0,boxx)




##plt.pcolormesh(np.transpose(dens_cy_sol_aver[-1]),cmap='hot')
#if save_figure:
#    plt.savefig(folder_name+'contact_angle_n'+str(concentrations[kk])+side_length+comment+'.pdf')
#    plt.close()
#else:
plt.show()
